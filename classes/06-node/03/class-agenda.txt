previous class recap
fs module in detail
utf8
utf8 vs ascii
try catch-to handle errors
==========================================================

1. Overview of the fs Module

    What is the fs Module?

    The fs (File System) module is a built-in Node.js module that allows you to interact with the file system on your computer.
    It provides methods to perform operations like reading, writing, updating, deleting, and renaming files.

    Why Use the fs Module?

    Essential for working with files and directories in a Node.js application.
    Enables reading from and writing to files, which is useful for tasks like logging, configuration management, and data storage.

2. Importing the fs Module Using ES Modules
    
    How to Import:

    Use the import statement to bring in the fs module.

    Code Example:

    import fs from 'fs';

3. Reading Files

    Reading a File Synchronously:
        fs.readFileSync reads the content of a file synchronously (blocking).
        Suitable for cases where you need the file content before proceeding.

        Code Example:

        import fs from 'fs';
        const data = fs.readFileSync('example.txt', 'utf8');
        console.log(data);

    Reading a File Asynchronously:
        fs.readFile reads the content of a file asynchronously (non-blocking).
        Better for performance, especially with large files.

        Code Example:

        import { promises as fsPromises } from 'fs';

        async function readFileAsync() {
        try {
            const data = await fsPromises.readFile('example.txt', 'utf8');
            console.log(data);
        } catch (err) {
            console.error('Error reading file:', err);
        }
        }

        readFileAsync();

4. Writing Files
    
    Writing to a File Synchronously:

    fs.writeFileSync writes data to a file synchronously.
    If the file doesn’t exist, it will be created; if it does, it will be overwritten.

    Code Example:

    import fs from 'fs';

    const content = 'Hello, World!';
    fs.writeFileSync('example.txt', content);
    console.log('File written successfully');

    Writing to a File Asynchronously:

    fs.writeFile writes data to a file asynchronously.
    Allows for handling the file write process without blocking the event loop.

    Code Example:

    import { promises as fsPromises } from 'fs';

    async function writeFileAsync() {
    try {
        const content = 'Hello, World!';
        await fsPromises.writeFile('example.txt', content);
        console.log('File written successfully');
    } catch (err) {
        console.error('Error writing file:', err);
    }
    }

    writeFileAsync();

5. Appending to Files

    Appending Data Asynchronously:

    fs.appendFile allows adding content to an existing file without overwriting it.

    Code Example:

    import { promises as fsPromises } from 'fs';

    async function appendFileAsync() {
    try {
        const additionalContent = '\nThis is appended content.';
        await fsPromises.appendFile('example.txt', additionalContent);
        console.log('Content appended successfully');
    } catch (err) {
        console.error('Error appending to file:', err);
    }
    }

    appendFileAsync();

6. Deleting Files
    
    Deleting a File Asynchronously:

    fs.unlink removes a file from the file system.

    Code Example:

    import { promises as fsPromises } from 'fs';

    async function deleteFileAsync() {
    try {
        await fsPromises.unlink('example.txt');
        console.log('File deleted successfully');
    } catch (err) {
        console.error('Error deleting file:', err);
    }
    }

    deleteFileAsync();

What is utf8?
    UTF-8 (Unicode Transformation Format - 8-bit) is a standard encoding system for representing text in computers. It encodes all possible characters (from all writing systems) using 1 to 4 bytes, making it compatible with ASCII and efficient for text storage and transmission.

utf8 vs ascii:

    Character Range:
        ASCII: 128 characters.
        UTF-8: Over a million characters.
    
    Encoding:
        ASCII: Fixed 7-bit encoding (1 byte).
        UTF-8: Variable-length encoding (1 to 4 bytes).
    
    Language Support:
        ASCII: Only basic English characters.
        UTF-8: Supports characters from all languages, symbols, and emojis.
    
    Compatibility:
        ASCII: Not compatible with other encoding systems.
        UTF-8: Backward-compatible with ASCII.

Practice Tasks:
Task 1: Read a file using both synchronous and asynchronous methods. Compare the behavior and output.
Task 2: Write a new file with some content, then append additional content to the same file.
Task 3: Delete a file and handle any errors if the file doesn’t exist.